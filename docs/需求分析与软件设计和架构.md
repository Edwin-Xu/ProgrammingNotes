

# 需求分析

## 基本概念

在创建一个新系统时，确定新系统的**目的、范围、定义、功能**，真针对软件需求进行**分析、记录、确认、管理**。













## 需求分析 in Qunar

- 需求idea

- 需求RDQA 开发、测试、产品等需求评审
  - 涉及页面改动：
    - 原型图、UI、版本控制
  - 涉及流程改动
  - 软件可靠性：监控、埋点、验证方案，新旧逻辑处理，性能，安全

- 需求估时

- 需求FR：leader决定需求投入、输出成本等



现状是怎么样？为了结局什么问题，数据说话，量化描述，真实可靠



需求估时：验收方案 改动点记录 相关开发熟悉评估 工时评估 自测自发





## 软件设计

### 软件开发过程的设计

数据建模，ER，UML，用例图 类图 流程图 时序图

### DDD

#### 背景

在微服务领域，需要对一个应用进行服务划分，划分的粒度需要适中，不能过大或者过小。

服务划分包含一些具体的工作，如：如何抽象具有统一业务范畴的model，使其模块化； 如何高度提炼并组合多模块，是业务可独立服务化。

DDD是解决服务划分的一种思路。

#### What's DDD

软件开发前，我们需要了解产品、行业领域，通过业务知识的梳理，形成某个领域知识，根据领域知识来进一步驱动软件设计。这是DDD的基本概念。

#### 软件开发 Vs. DDD

软件开发方式有 瀑布式、敏捷等

瀑布式是根据具体的流程就行，敏捷则更加灵活，拥抱变化。

DDD则是更加小粒度的迭代设计，它的最小单元是 **领域模型(Domain Model)**, 所谓DM就是能够精确反映领域中某一知识元素的载体，这种知识的获取需要通过与 **领域专家Domain Expert**进行频繁的沟通才能将专业知识转化为领域模型。

**领域模型无关技术**，具有高度的业务抽象性，它能够精确的描述领域中的知识体系。同时它也是独立的，我们还需要学会如何让它具有表达性，让模型彼此之间建立关系，形成完整的领域架构。

通常我们可以用象形图或一种`通用的语言(Ubiquitous Language)`去描述它们之间的关系。在此之上，我们就可以进行`领域中的代码设计(Domain Code Design)`。

#### 建立领域知识模型(Build Domain Model)

现要为航空公司开发一款能够为飞机提供导航，保证无路线冲突监控软件。那我们应该从哪里开始下手呢？根据DDD的思路，我们第一步是`建立领域知识`：作为平时管理和维护机场飞行秩序的工作人员来说，他们自然就是这个领域的专家，我们第一个目标就是与他们沟通，也许我们并不能从中获取所有想要的知识，但至少可以筛选出主要的内容和元素。

#### 通用语言Ubiquitous Language

开发人员和领域专家的沟通存在天然屏障，我们的开发思维是领域专家所不能了解的，他们只熟知在他们所在领域的知识。

所以需要通用语言，用于交流，有多种通用语言

- UML
- 伪代码

#### 领域和子域

领域并不是多么高深的概念，比如，一个保险公司的领域中包含了保险单、理赔和再保险等概念；一个电商网站的领域包含了产品名录、订单、发票、库存和物流的概念。这里，我主要讲讲对领域的划分，即将一个大的领域划分成若干个子域。

在DDD中，我们对系统的划分是基于领域的，也即是基于业务的。

如何划分领域？答案是限界上下文/上下文映射图。

#### 限界上下文（Bounded Context）

在一个领域/子域中，我们会创建一个概念上的领域边界，在这个边界中，任何领域对象都只表示特定于该边界内部的确切含义。这样边界便称为限界上下文。限界上下文和领域具有一对一的关系。

举个例子，同样是一本书，在出版阶段和出售阶段所表达的概念是不同的，出版阶段我们主要关注的是出版日期，字数，出版社和印刷厂等概念，而在出售阶段我们则主要关心价格，物流和发票等概念。

对于上文中提到的各个子域之间的集成问题，其实也是限界上下文之间的集成问题。在集成时，我们主要关心的是领域模型和集成手段之间的关系。比如需要与一个REST资源集成，你需要提供基础设施（比如Spring 中的RestTemplate），但是这些设施并不是你核心领域模型的一部分，你应该怎么办呢？答案是防腐层，该层负责与外部服务提供方打交道，还负责将外部概念翻译成自己的核心领域能够理解的概念。当然，防腐层只是限界上下文之间众多集成方式的一种，另外还有共享内核、开放主机服务等，具体细节请参考《实现领域驱动设计》原书。限界上下文之间的集成关系也可以理解为是领域概念在不同上下文之间的映射关系，因此，限界上下文之间的集成也称为上下文映射图。



#### 架构风格

DDD并限于某一种风格，可以是三层式，可以是REST。

但是在《实现领域驱动设计》中，作者比较推崇**事件驱动架构和六边形（Hexagonal）架构**。

当下，**面向接口编程和依赖注入原则已经在颠覆着传统的分层架构**，如果再进一步，我们便得到了**六边形架构，也称为`端口和适配器（Ports and Adapters）`**。在六边形架构中，已经**不存在分层的概念，所有组件都是平等的**。这主要得益于软件抽象的好处，即各个组件的之间的交互完全通过接口完成，而不是具体的实现细节。（**抽象不应该依赖于细节，细节应该依赖于抽象。**）

采用六边形架构的系统中存在着很多端口和适配器的组合。端口表示的是一个软件系统的输入和输出，而适配器则是对每一个端口的访问方式。比如，在一个Web应用程序中，HTTP协议可以作为一个端口，它向用户提供HTML页面并且接受用户的表单提交；而Servlet（对于Java而言）或者Spring中的Controller则是相对应于HTTP协议的适配器。再比如，要对数据进行持久化，此时的数据库系统则可看成是一个端口，而访问数据库的Driver则是相应于数据库的适配器。如果要为系统增加新的访问方式，你只需要为该访问方式添加一个相应的**端口和适配器**即可。

领域模型又如何与端口和适配器进行交互呢？

软件系统的真正价值在于提供业务功能，我们会将所有的业务功能分解为若干个业务用例，每一次业务用例都表示对软件系统的一次原子操作。所以首先，软件系统中应该存在这样的组件，他们的作用即**以业务用例为单位向外界暴露该系统的业务功能**。在DDD中，这样的组件称为应用层（Application Layer）。

<img src="需求分析与软件设计和架构.assets/image-20210814202850235.png" alt="image-20210814202850235" style="zoom:75%;" />

在有了应用层之后，软件系统和外界的交互便变成了适配器和应用层之间的交互

领域模型位于应用程序的核心部分, 应用层中不应该包含有业务逻辑，否则就造成了领域逻辑的泄漏. 而应该是很薄的一层，主要起到协调的作用，它所做的只是将业务操作代理给我们的领域模型。

应用层实际是系统门面（Facade） (fa sa de)。**即采用外观模式**





#### 领域驱动设计 Domain Driven Design

DDD将一个软件系统的核心业务功能集中在一个核心域里面，其中包含了实体、值对象、领域服务、资源库和聚合等概念。在此基础上，DDD提出了一套完整的支撑这样的核心领域的基础设施。此时，DDD已经不再是“面向对象进阶”那么简单了，而是演变成了一个系统工程。

##### 行为饱满的领域对象

我们希望领域对象能够准确地表达出业务意图，但是多数时候，我们所看到的却是充满getter和setter的领域对象，此时的领域对象已经不是领域对象了，而是Martin Fowler所称之为的**[贫血对象](_images/http://martinfowler.com/bliki/AnemicDomainModel.html)**。

放到Java世界中，多年以来，**Java Bean规范都引诱着程序员们以“自然而然又合乎情理”的方式创建着无数的贫血对象**，虽然有缺陷，但很多时候是信息隐藏、封装的OO思想的必然实现。

要创建行为饱满的领域对象并不难，我们需要转变一下思维，将领域对象当做是服务的提供方，而不是数据容器，多思考一个领域对象能够提供哪些行为，而不是数据。

##### 贫血模型 vs. 充血模型

贫血模型：**是指领域对象里只有get和set方法，或者包含少量的CRUD方法，所有的业务逻辑都不包含在内而是放在Business Logic层**。

优点是系统的层次结构清楚，各层之间单向依赖，Client->(Business Facade)->Business Logic->Data Access(ADO.NET)。当然Business Logic是依赖Domain Object的。似乎现在流行的架构就是这样，当然层次还可以细分。 

该模型的缺点是不够面向对象，领域对象只是作为保存状态或者传递状态使用，所以就说只有数据没有行为的对象不是真正的对象。在Business Logic里面处理所有的业务逻辑，在POEAA(企业应用架构模式)一书中被称为Transaction Script模式。



充血模型： 层次结构和上面的差不多，不过大多业务逻辑和持久化放在Domain Object里面，Business Logic只是简单封装部分业务逻辑以及控制事务、权限等，这样层次结构就变成Client->（Business Facade)->Business Logic->Domain Object->Data Access。

优点是面向对象，Business Logic符合单一职责，不像在贫血模型里面那样包含所有的业务逻辑太过沉重。 

缺点是如何划分业务逻辑，什么样的逻辑应该放在Domain Object中，什么样的业务逻辑应该放在Business Logic中，这是很含糊的。即使划分好了业务逻辑，由于分散在Business Logic和Domain Object层中，不能更好的分模块开发。熟悉业务逻辑的开发人员需要渗透到Domain Logic中去，而在Domain Logic又包含了持久化，对于开发者来说这十分混乱。 其次，因为Business Logic要控制事务并且为上层提供一个统一的服务调用入口点，它就必须把在Domain Logic里实现的业务逻辑全部重新包装一遍，完全属于重复劳动。



##### 实体vs值对象（Entity vs Value Object）

在一个软件系统中，实体表示那些具有生命周期并且会在其生命周期中发生改变的东西；而值对象则表示起描述性作用的并且可以相互替换的概念。

具体到实现层面，值对象是没有唯一标识的，他的equals()方法（比如在Java语言中）可以用它所包含的描述性属性字段来实现。但是，对于实体而言，equals()方法便只能通过唯一标识来实现了，因为即便两个实体所拥有的状态是一样的，他们依然是不同的实体

我们发现，多数领域概念都可以建模成值对象，而非实体。值对象就像软件系统中的过客一样，具有“创建后不管”的特征，因此，我们不需要像关心实体那样去关心诸如生命周期和持久化等问题。

##### 聚合 Aggregate

聚合中所包含的对象之间具有密不可分的联系，他们是内聚在一起的。

比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。一个聚合中可以包含多个实体和值对象，因此聚合也被称为根实体。聚合是持久化的基本单位，它和资源库（请参考下文）具有一一对应的关系。

##### 领域服务（Domain Service）

领域服务用来处理 ： 想建模一个领域概念，把它放在实体上不合适，把它放在值对象上也不合适

##### 资源库（Repository）

资源库用于保存和获取聚合对象，在这一点上，资源库与DAO多少有些相似之处。但是，资源库和DAO是存在显著区别的。DAO只是对数据库的一层很薄的封装，而资源库则更加具有领域特征。

资源库分为两种，一种是基于集合的，一种是基于持久化的。顾名思义，基于集合的资源库具有编程语言中集合的特征。举个例子，Java中的List，我们从一个List中取出一个元素，在对该元素进行修改之后，我们并不用显式地将该元素重新保存到List里面。

##### 领域事件（Domain Event）

在传统的软件系统中，对数据一致性的处理都是通过事务完成的，其中包括本地事务和全局事务。但是，DDD的一个重要原则便是一次事务只能更新一个聚合实例。然而，的确存在需要修改多个聚合的业务用例，那么此时我们应该怎么办呢？

**最终一致性取代了事务一致性**，通过领域事件的方式达到各个组件之间的数据一致性。



#### DDD 实现

Cola： 阿里DDD的一种实现？

https://github.com/alibaba/COLA



这个课还不错：https://www.bilibili.com/video/BV1hq4y1p74E?p=1



### 中台













心态 能力 知识 观念



先是思想和观念，由认知决定，其次才是能力和方法





不要设限，不要给自己、被他人贴标签







## 软件架构

### SDK的封装

这封装组件`SDK`分为组件设计、开发、接入、上线

https://zhuanlan.zhihu.com/p/368904858



### BFF

BFF，即 Backend For Frontend（服务于前端的后端），也就是服务器设计 API 时会考虑前端的使用，并在服务端直接进行业务逻辑的处理，又称为用户体验适配器。BFF 只是一种逻辑分层，而非一种技术，虽然 BFF 是一个新名词，但它的理念由来已久。



此时，每次访问该页面都需要发送 3 个请求。同时为了保障 Android，iOS，以及 Web 端的不同需求，需要为不同的平台写不同的 API 接口，而每当值发生一些变化时，需要 Android，iOS，Web 做出修改。与此同时，当我们需要对一个字符串进行处理，如限定 140 个字符的时候，我们需要在每一个客户端（Android，iOS，Web）分别实现一遍，这样的代价显然相当大。

于是，我们就需要 BFF 作为中间件。在这个中间件上我们将做一些业务逻辑处理：

而当我们有了 BFF 这一层时，我们就不需要考虑系统后端的迁移。后端发生的变化都可以在 BFF 层做一些响应的修改。



使用 BFF 的正确姿势

- 多端应用
   我们在设计 API 时会考虑到不同设备的需求，也就是为不同的设备提供不同的 API，虽然它们可能是实现相同的功能，但因为不同设备的特殊性，它们对服务端的 API 访问也各有其特点，需要区别处理。
- 服务聚合
   随着微服务的兴起，原本在同一个进程内运行的业务流程被拆分到了不同的服务中。这在增加业务灵活性的同时，也让前端的调用变得更复杂。BFF 的出现为前端应用提供了一个对业务服务调用的聚合点，它屏蔽了复杂的服务调用链，让前端可以聚焦在所需要的数据上，而不用关注底层提供这些数据的服务。
- 非必要，莫新增
   我们在看到 BFF 带来的各种好处的同时，也要注意到它所带来的代码重复和工作量增加方面的问题。如果与已有 BFF 功能类似，且展现数据的要求也相近的话，一定要谨慎对待新增 BFF 的行为。因此，建议**非必要，莫新增**。































